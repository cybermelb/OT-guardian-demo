import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { initializeApp } from 'firebase/app';
import { getFirestore, doc, setDoc, collection, query, onSnapshot, serverTimestamp, setLogLevel } from 'firebase/firestore';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from 'firebase/auth'; // Import Auth services
import { X, CheckCircle, AlertTriangle, Cpu, HardHat, BarChart2, Shield, Settings, User, BookOpen, Clock, Zap, Target, MapPin, Users, Filter, ArrowDownUp, LogOut, ArrowRight, TrendingUp, TrendingDown, Eye, Layers } from 'lucide-react';

// --- CONFIGURATION CHECK & CONSTANTS ---
let firebaseConfig = {};
let appId = 'default-app-id';

try {
  // Use global variables provided by the Canvas environment
  const fConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
  const aId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
  
  if (fConfig && fConfig.apiKey && fConfig.projectId) {
      firebaseConfig = fConfig;
      appId = aId;
  }
} catch (e) {
  // Fallback or error handling for config loading
  console.error("Failed to load Firebase config:", e);
}

// Set up logging for Firebase, useful for debugging
setLogLevel('debug');

// --- UTILITY FUNCTIONS ---

/**
 * Constructs the Firestore collection path for public artifacts.
 * @param {string} collectionName The name of the sub-collection (e.g., 'risks').
 * @returns {string} The full Firestore path.
 */
const getPublicCollectionPath = (collectionName) => 
  `/artifacts/${appId}/public/data/${collectionName}`;

/**
 * Constructs the Firestore document path for public artifacts.
 * @param {string} collectionName 
 * @param {string} docId 
 * @returns {string}
 */
const getPublicDocumentPath = (collectionName, docId) => 
  `${getPublicCollectionPath(collectionName)}/${docId}`;


/**
 * Simple function to generate a random UUID for temporary local use if needed.
 */
const generateRandomId = () => crypto.randomUUID();


// --- MOCK DATA STRUCTURES (Used for initial state and type hints) ---

// Define core data structures (using JSDoc for type hinting in React state)

/**
 * @typedef {Object} Asset
 * @property {string} id - Unique ID.
 * @property {string} name - Human-readable name (e.g., "PLC-001").
 * @property {string} type - Asset type (e.g., "PLC", "HMI", "Historian").
 * @property {string} location - Physical location (e.g., "Substation A", "Control Room").
 * @property {string} networkZone - Network segment (e.g., "L3.5 DMZ", "L2 Control").
 * @property {string} criticality - Business impact (High, Medium, Low).
 * @property {number} installedBase - Number of similar assets deployed.
 * @property {string} lastUpdated - ISO string of last update time.
 */

/**
 * @typedef {Object} Risk
 * @property {string} id - Unique ID.
 * @property {string} assetId - The ID of the affected asset.
 * @property {string} title - Short description of the risk (e.g., "Unpatched OS vulnerability").
 * @property {string} vulnerability - CVE or equivalent identifier.
 * @property {string} threat - The threat agent (e.g., "Remote Attacker", "Insider").
 * @property {string} likelihood - Likelihood (High, Medium, Low).
 * @property {string} impact - Impact (High, Medium, Low).
 * @property {string} riskScore - Calculated score (e.g., "CRITICAL", "HIGH").
 * @property {string} status - Current status (Open, In Progress, Mitigated, Accepted).
 */

/**
 * @typedef {Object} Control
 * @property {string} id - Unique ID.
 * @property {string} name - Name of the control (e.g., "Network Segmentation", "Patch Management").
 * @property {string} type - Control category (e.g., "Preventative", "Detective").
 * @property {string} status - Compliance status (Compliant, Non-Compliant, N/A).
 * @property {string} description - Detailed description.
 * @property {string[]} appliedTo - Array of asset IDs the control applies to.
 */

/**
 * @typedef {Object} RemediationTask
 * @property {string} id - Unique ID.
 * @property {string} riskId - The risk this task addresses.
 * @property {string} description - Task description (e.g., "Apply patch MS-1234").
 * @property {string} responsibleTeam - Team responsible (e.g., "OT Engineering", "IT Security").
 * @property {string} dueDate - Target completion date (ISO string).
 * @property {string} status - Task status (Pending, In Progress, Complete, Delayed).
 */


// --- REACT COMPONENT: App ---

/**
 * The main application component for the OT Guardian Deployment Demo.
 * Manages Firebase connection, state, and routing.
 */
const App = () => {
  // --- STATE MANAGEMENT ---
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAdmin, setIsAdmin] = useState(false);
  const [isAuthReady, setIsAuthReady] = useState(false);

  /** @type {[Asset[], React.Dispatch<React.SetStateAction<Asset[]>>]} */
  const [assets, setAssets] = useState([]);
  /** @type {[Risk[], React.Dispatch<React.SetStateAction<Risk[]>>]} */
  const [risks, setRisks] = useState([]);
  /** @type {[Control[], React.Dispatch<React.SetStateAction<Control[]>>]} */
  const [controls, setControls] = useState([]);
  /** @type {[RemediationTask[], React.Dispatch<React.SetStateAction<RemediationTask[]>>]} */
  const [tasks, setTasks] = useState([]);

  const [currentView, setCurrentView] = useState('riskDashboard'); // Current view in the application
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // --- FIREBASE INITIALIZATION & AUTH ---

  useEffect(() => {
    try {
      if (!firebaseConfig.apiKey) {
        throw new Error("Firebase configuration is missing or invalid.");
      }
      
      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const authService = getAuth(app);
      
      setDb(firestore);
      setAuth(authService);

      // 1. Listen for Auth State Changes
      const unsubscribeAuth = onAuthStateChanged(authService, async (user) => {
        if (user) {
          const currentUserId = user.uid;
          setUserId(currentUserId);
          
          // Simple mock admin check: if UID is 'admin_user_id', set isAdmin true
          // In a real app, this would query a user roles collection.
          setIsAdmin(currentUserId === 'admin_user_id'); 
        } else {
          // Attempt sign in if not authenticated (using custom token if available, else anonymous)
          const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
          try {
            if (initialAuthToken) {
              await signInWithCustomToken(authService, initialAuthToken);
            } else {
              await signInAnonymously(authService);
            }
          } catch (e) {
            console.error("Auth sign-in failed:", e);
            setError("Could not sign in to Firebase. Check configuration and security rules.");
          }
        }
        setIsAuthReady(true); // Auth process is complete/ready
      });

      return () => unsubscribeAuth();
    } catch (e) {
      console.error("Firebase initialization failed:", e);
      setError(`Initialization Error: ${e.message}`);
      setLoading(false);
    }
  }, []);

  // --- FIRESTORE DATA SUBSCRIPTIONS (Real-time listeners) ---

  useEffect(() => {
    if (!isAuthReady || !db) return;

    setLoading(true);

    const collections = [
      { name: 'assets', setter: setAssets },
      { name: 'risks', setter: setRisks },
      { name: 'controls', setter: setControls },
      { name: 'tasks', setter: setTasks },
    ];

    const unsubscribes = collections.map(({ name, setter }) => {
      try {
        const colPath = getPublicCollectionPath(name);
        const q = query(collection(db, colPath));
        
        const unsubscribe = onSnapshot(q, (snapshot) => {
          const dataList = [];
          snapshot.forEach(doc => {
            dataList.push({ id: doc.id, ...doc.data() });
          });
          setter(dataList);
          setLoading(false);
        }, (err) => {
          console.error(`Error listening to ${name} collection:`, err);
          setError(`Error fetching data for ${name}: ${err.message}`);
          setLoading(false);
        });

        return unsubscribe;

      } catch (e) {
        console.error(`Error setting up listener for ${name}:`, e);
        setError(`Data Listener Setup Error: ${e.message}`);
        setLoading(false);
        return () => {}; // Return a no-op function for consistency
      }
    });

    return () => unsubscribes.forEach(unsub => unsub());
  }, [isAuthReady, db]); // Rerun when auth is ready and db is set

  // --- DATA PROCESSING & CALCULATIONS (Memoized for performance) ---

  // Aggregate Risk Data for Dashboard
  const riskSummary = useMemo(() => {
    const totalRisks = risks.length;
    const mitigatedRisks = risks.filter(r => r.status === 'Mitigated').length;
    const highRisks = risks.filter(r => r.riskScore === 'CRITICAL' || r.riskScore === 'HIGH').length;
    const lowRisks = risks.filter(r => r.riskScore === 'LOW').length;
    const openTasks = tasks.filter(t => t.status !== 'Complete').length;

    const riskByZone = risks.reduce((acc, risk) => {
        const asset = assets.find(a => a.id === risk.assetId);
        const zone = asset ? asset.networkZone : 'Unknown';
        acc[zone] = (acc[zone] || 0) + 1;
        return acc;
    }, {});

    return {
      totalRisks,
      mitigatedRisks,
      highRisks,
      lowRisks,
      openTasks,
      riskByZone,
    };
  }, [risks, assets, tasks]);
  
  // Risk Score Mapping Helper
  const getRiskScoreDetails = (riskScore) => {
    switch (riskScore) {
      case 'CRITICAL': return { color: 'bg-red-700', text: 'Critical', icon: <X /> };
      case 'HIGH': return { color: 'bg-orange-500', text: 'High', icon: <AlertTriangle /> };
      case 'MEDIUM': return { color: 'bg-yellow-500', text: 'Medium', icon: <AlertTriangle /> };
      case 'LOW': return { color: 'bg-green-500', text: 'Low', icon: <CheckCircle /> };
      default: return { color: 'bg-gray-400', text: 'N/A', icon: <AlertTriangle /> };
    }
  };

  // Status mapping for Tasks
  const getTaskStatusDetails = (status) => {
    switch (status) {
      case 'Complete': return { color: 'bg-green-500', text: 'Complete', icon: <CheckCircle /> };
      case 'In Progress': return { color: 'bg-blue-500', text: 'In Progress', icon: <Clock /> };
      case 'Pending': return { color: 'bg-yellow-500', text: 'Pending', icon: <Zap /> };
      case 'Delayed': return { color: 'bg-red-500', text: 'Delayed', icon: <AlertTriangle /> };
      default: return { color: 'bg-gray-400', text: 'N/A', icon: <Eye /> };
    }
  };


  // --- FIRESTORE WRITE OPERATIONS ---

  /**
   * Universal function to save/update an object in a collection.
   * Uses serverTimestamp for auditability.
   * @param {string} collectionName 
   * @param {Object} data 
   * @param {string | undefined} id 
   */
  const saveDocument = useCallback(async (collectionName, data, id) => {
    if (!db) {
      setError("Database connection not ready.");
      return;
    }
    try {
      const colRef = collection(db, getPublicCollectionPath(collectionName));
      const docData = { ...data, lastUpdated: serverTimestamp() };

      if (id) {
        // Update existing document
        const docRef = doc(db, getPublicDocumentPath(collectionName, id));
        await updateDoc(docRef, docData);
      } else {
        // Add new document
        await addDoc(colRef, docData);
      }

      // Clear any previous error
      setError(null);

    } catch (e) {
      console.error(`Error saving document to ${collectionName}:`, e);
      setError(`Failed to save document. Permission denied or network issue.`);
    }
  }, [db]);

  // Specific save functions for clarity
  const saveAsset = (asset, id) => saveDocument('assets', asset, id);
  const saveRisk = (risk, id) => saveDocument('risks', risk, id);
  const saveControl = (control, id) => saveDocument('controls', control, id);
  const saveTask = (task, id) => saveDocument('tasks', task, id);

  // --- UI Components ---

  // Helper for admin access check
  const checkAdminAccess = () => isAdmin;

  /**
   * Renders the Risk Dashboard view.
   */
  const RiskDashboard = () => (
    <div className="p-4 md:p-8 space-y-8">
      <h2 className="text-3xl font-extrabold text-gray-900 flex items-center">
        <Shield className="w-8 h-8 mr-3 text-indigo-600" />
        OT Cyber Risk Overview
      </h2>
      <div className="text-sm text-gray-500">
        User ID: <span className="font-mono text-gray-700">{userId || 'Loading...'}</span>
      </div>
      
      {/* Risk Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        {/* Total Risks */}
        <DashboardCard 
          title="Total Risks Identified" 
          value={riskSummary.totalRisks} 
          icon={<AlertTriangle className="text-indigo-500" />}
          trend={<TrendingUp className="text-red-500" />}
          description="Total vulnerabilities across all assets."
        />
        {/* High/Critical Risks */}
        <DashboardCard 
          title="High/Critical Risks" 
          value={riskSummary.highRisks} 
          icon={<Zap className="text-red-500" />}
          trend={<TrendingDown className="text-green-500" />}
          description={`Target for closure: ${Math.max(0, riskSummary.highRisks - 5)}`}
        />
        {/* Open Remediation Tasks */}
        <DashboardCard 
          title="Open Remediation Tasks" 
          value={riskSummary.openTasks} 
          icon={<HardHat className="text-yellow-500" />}
          trend={<TrendingUp className="text-orange-500" />}
          description="Awaiting action by responsible teams."
        />
        {/* Control Compliance */}
        <DashboardCard 
          title="Controls Non-Compliant" 
          value={controls.filter(c => c.status === 'Non-Compliant').length} 
          icon={<CheckCircle className="text-green-500" />}
          trend={<TrendingDown className="text-green-500" />}
          description="Focus on restoring compliance."
        />
      </div>

      {/* Detailed Risk and Asset Breakdown */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Risk By Network Zone */}
        <div className="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg">
          <h3 className="text-xl font-semibold text-gray-800 mb-4 flex items-center"><Layers className="w-5 h-5 mr-2 text-indigo-500"/> Risk by Network Zone</h3>
          <div className="space-y-3">
            {Object.entries(riskSummary.riskByZone).sort(([, a], [, b]) => b - a).map(([zone, count]) => (
              <div key={zone} className="flex items-center justify-between">
                <span className="text-gray-600 font-medium">{zone}</span>
                <div className="flex items-center space-x-2 w-3/4">
                  <div className="h-2 bg-indigo-200 rounded-full flex-grow">
                    <div 
                      className="h-full bg-indigo-600 rounded-full" 
                      style={{ width: `${(count / riskSummary.totalRisks) * 100}%` }}
                    ></div>
                  </div>
                  <span className="text-sm font-bold text-indigo-700">{count}</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Top Risky Assets */}
        <div className="bg-white p-6 rounded-xl shadow-lg">
          <h3 className="text-xl font-semibold text-gray-800 mb-4 flex items-center"><Cpu className="w-5 h-5 mr-2 text-red-500"/> Top Risky Assets</h3>
          <ul className="space-y-3">
            {risks.reduce((acc, risk) => {
              const asset = assets.find(a => a.id === risk.assetId);
              if (asset && (risk.riskScore === 'CRITICAL' || risk.riskScore === 'HIGH')) {
                acc[asset.name] = (acc[asset.name] || 0) + 1;
              }
              return acc;
            }, {})
            |> (obj => Object.entries(obj).sort(([, a], [, b]) => b - a).slice(0, 5)) 
            |> (topAssets => topAssets.map(([name, count]) => (
              <li key={name} className="flex justify-between items-center p-2 bg-gray-50 rounded-lg">
                <span className="text-gray-700">{name}</span>
                <span className="px-3 py-1 text-xs font-semibold rounded-full bg-red-100 text-red-800">{count} Risks</span>
              </li>
            )))}
          </ul>
        </div>
      </div>
      
      {/* Risk Table */}
      <DataGrid 
        title="Active Risks" 
        data={risks} 
        columns={[
          { header: 'ID', accessor: 'id', render: (val) => <span className="font-mono text-xs">{val.substring(0, 8)}...</span> },
          { header: 'Asset', accessor: 'assetId', render: (val) => assets.find(a => a.id === val)?.name || 'N/A' },
          { header: 'Title', accessor: 'title' },
          { header: 'Vulnerability', accessor: 'vulnerability' },
          { header: 'Score', accessor: 'riskScore', render: (val) => <Pill {...getRiskScoreDetails(val)} /> },
          { header: 'Status', accessor: 'status' },
        ]}
        // This is a view-only table for the dashboard
        onRowClick={null}
      />
    </div>
  );

  /**
   * Renders the Asset Builder (CRUD) view.
   */
  const AssetBuilder = () => (
    <CrudView 
      title="OT Asset Inventory Builder"
      collectionName="assets"
      data={assets}
      initialForm={{ name: '', type: 'PLC', location: 'Field', networkZone: 'L2 Control', criticality: 'Medium', installedBase: 1 }}
      formFields={[
        { name: 'name', label: 'Asset Name (e.g. HMI-005)', type: 'text' },
        { name: 'type', label: 'Asset Type', type: 'select', options: ['PLC', 'HMI', 'RTU', 'Historian', 'Workstation', 'Firewall'] },
        { name: 'location', label: 'Physical Location', type: 'text' },
        { name: 'networkZone', label: 'Network Zone', type: 'select', options: ['L4 IT', 'L3.5 DMZ', 'L3 Manufacturing', 'L2 Control', 'L1 Basic Control'] },
        { name: 'criticality', label: 'Business Criticality', type: 'select', options: ['High', 'Medium', 'Low'] },
        { name: 'installedBase', label: 'Installed Base Count', type: 'number' },
      ]}
      tableColumns={[
        { header: 'Name', accessor: 'name' },
        { header: 'Type', accessor: 'type' },
        { header: 'Location', accessor: 'location' },
        { header: 'Zone', accessor: 'networkZone' },
        { header: 'Criticality', accessor: 'criticality' },
        { header: 'Base', accessor: 'installedBase' },
      ]}
      saveDocument={saveAsset}
      AssetIcon={Cpu}
    />
  );
  
  /**
   * Renders the Security Controls (CRUD) view.
   */
  const SecurityControls = () => (
    <CrudView 
      title="OT Security Controls Manager"
      collectionName="controls"
      data={controls}
      initialForm={{ name: '', type: 'Preventative', status: 'Compliant', description: '', appliedTo: [] }}
      formFields={[
        { name: 'name', label: 'Control Name', type: 'text' },
        { name: 'type', label: 'Control Type', type: 'select', options: ['Preventative', 'Detective', 'Corrective'] },
        { name: 'status', label: 'Compliance Status', type: 'select', options: ['Compliant', 'Non-Compliant', 'N/A'] },
        { name: 'description', label: 'Description', type: 'textarea' },
        // Multi-select for assets (simplified implementation)
        { 
            name: 'appliedTo', 
            label: 'Applies to Assets (IDs)', 
            type: 'text', 
            placeholder: 'Comma-separated Asset IDs (e.g., plc-01,hmi-02)'
        }
      ]}
      tableColumns={[
        { header: 'Name', accessor: 'name' },
        { header: 'Type', accessor: 'type' },
        { header: 'Status', accessor: 'status' },
        { header: 'Description', accessor: 'description' },
        { header: 'Applies To', accessor: 'appliedTo', render: (val) => Array.isArray(val) ? `${val.length} assets` : 'N/A' },
      ]}
      saveDocument={(formData, id) => {
        // Simple conversion for the text input back into an array of strings
        const dataToSave = { 
            ...formData, 
            appliedTo: formData.appliedTo 
                ? (typeof formData.appliedTo === 'string' ? formData.appliedTo.split(',').map(s => s.trim()).filter(s => s) : formData.appliedTo)
                : []
        };
        saveControl(dataToSave, id);
      }}
      AssetIcon={CheckCircle}
    />
  );
  
  /**
   * Renders the Remediation Tasks (CRUD) view.
   */
  const RemediationTasks = () => (
    <CrudView 
      title="Remediation Task Tracker"
      collectionName="tasks"
      data={tasks}
      initialForm={{ riskId: '', description: '', responsibleTeam: 'OT Engineering', dueDate: new Date().toISOString().substring(0, 10), status: 'Pending' }}
      formFields={[
        // Select risk ID from existing risks for context
        { name: 'riskId', label: 'Associated Risk ID', type: 'select', options: risks.map(r => r.id), placeholder: 'Select a Risk ID' },
        { name: 'description', label: 'Task Description', type: 'textarea' },
        { name: 'responsibleTeam', label: 'Responsible Team', type: 'select', options: ['OT Engineering', 'IT Security', 'Vendor'] },
        { name: 'dueDate', label: 'Target Due Date', type: 'date' },
        { name: 'status', label: 'Task Status', type: 'select', options: ['Pending', 'In Progress', 'Complete', 'Delayed'] },
      ]}
      tableColumns={[
        { header: 'Risk ID', accessor: 'riskId', render: (val) => <span className="font-mono text-xs">{val.substring(0, 8)}...</span> },
        { header: 'Description', accessor: 'description' },
        { header: 'Team', accessor: 'responsibleTeam' },
        { header: 'Due Date', accessor: 'dueDate' },
        { header: 'Status', accessor: 'status', render: (val) => <Pill {...getTaskStatusDetails(val)} /> },
      ]}
      saveDocument={saveTask}
      AssetIcon={HardHat}
    />
  );

  /**
   * Renders the Admin view (Mock for role demonstration).
   */
  const AdminView = () => (
    <div className="p-8 space-y-6">
      <h2 className="text-3xl font-extrabold text-gray-900 flex items-center">
        <User className="w-8 h-8 mr-3 text-red-600" />
        Administrator Panel
      </h2>
      <div className="text-sm text-gray-500">
        This view is visible only because your User ID matches the mock admin ID.
        In a production application, this panel would manage user roles, security rules, and system configurations.
        <p className="mt-2 p-3 bg-red-50 text-red-700 rounded-lg border border-red-200">
            Current User ID: <span className="font-mono font-semibold">{userId}</span>
        </p>
      </div>

      <div className="bg-white p-6 rounded-xl shadow-lg border border-red-100">
        <h3 className="text-xl font-semibold text-gray-800 mb-4 flex items-center"><Settings className="w-5 h-5 mr-2 text-red-500"/> System Configuration Mock</h3>
        <p className="text-gray-600">
          From here, an administrator could provision new assets (using the Asset Builder), create default control templates, and set up user permissions. The current system uses a 'public' artifact collection model. A robust system would include private configuration collections and a user-role management interface.
        </p>
        <p className="mt-4 text-sm text-gray-500">
            **Action to Simulate:** You can manually add a new risk by creating a new document in the 'risks' collection via the Firebase console for a quick simulation of data injection.
        </p>
      </div>

      <CrudView 
        title="Risk Creation (Admin Access Only)"
        collectionName="risks"
        data={risks}
        initialForm={{ assetId: '', title: '', vulnerability: '', threat: 'Remote Attacker', likelihood: 'Medium', impact: 'Medium', riskScore: 'MEDIUM', status: 'Open' }}
        formFields={[
          { name: 'assetId', label: 'Asset ID', type: 'select', options: assets.map(a => a.id), placeholder: 'Select Target Asset ID' },
          { name: 'title', label: 'Risk Title', type: 'text' },
          { name: 'vulnerability', label: 'Vulnerability (e.g. CVE-2023-1234)', type: 'text' },
          { name: 'threat', label: 'Threat Agent', type: 'select', options: ['Remote Attacker', 'Insider', 'Malware', 'Natural Disaster'] },
          { name: 'likelihood', label: 'Likelihood', type: 'select', options: ['High', 'Medium', 'Low'] },
          { name: 'impact', label: 'Impact', type: 'select', options: ['High', 'Medium', 'Low'] },
          { name: 'status', label: 'Status', type: 'select', options: ['Open', 'In Progress', 'Mitigated', 'Accepted'] },
          // Risk Score is calculated, but included for manual override or initial entry
          { name: 'riskScore', label: 'Risk Score (Calculated)', type: 'select', options: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'] },
        ]}
        tableColumns={[
          { header: 'Asset', accessor: 'assetId', render: (val) => assets.find(a => a.id === val)?.name || 'N/A' },
          { header: 'Title', accessor: 'title' },
          { header: 'Score', accessor: 'riskScore', render: (val) => <Pill {...getRiskScoreDetails(val)} /> },
          { header: 'Status', accessor: 'status' },
        ]}
        saveDocument={saveRisk}
        AssetIcon={AlertTriangle}
      />
    </div>
  );


  // --- GENERIC SUB-COMPONENTS ---

  /**
   * Generic Card for Dashboard Metrics.
   * @param {Object} props
   * @param {string} props.title
   * @param {number} props.value
   * @param {React.ReactNode} props.icon
   * @param {React.ReactNode} props.trend
   * @param {string} props.description
   */
  const DashboardCard = ({ title, value, icon, trend, description }) => (
    <div className="bg-white p-6 rounded-xl shadow-lg transition duration-300 hover:shadow-xl border-t-4 border-indigo-600">
      <div className="flex justify-between items-start">
        <div className="text-sm font-medium text-gray-500">{title}</div>
        <div className="p-2 bg-indigo-100 rounded-full text-indigo-600">
          {icon}
        </div>
      </div>
      <div className="mt-1 flex items-baseline justify-between">
        <p className="text-3xl font-bold text-gray-900">{value}</p>
        <div className="flex items-center text-sm ml-2">
          {trend}
          <span className="ml-1 text-gray-500">{description}</span>
        </div>
      </div>
    </div>
  );

  /**
   * Generic Pill for Status/Risk Score visualization.
   * @param {Object} props
   * @param {string} props.color - Tailwind background class (e.g., 'bg-red-500').
   * @param {string} props.text - The text to display.
   * @param {React.ReactNode} props.icon - Lucide icon component.
   */
  const Pill = ({ color, text, icon }) => (
    <span className={`inline-flex items-center px-3 py-1 rounded-full text-xs font-semibold uppercase ${color} text-white shadow-sm`}>
      <span className="w-3 h-3 mr-1">{icon}</span>
      {text}
    </span>
  );

  /**
   * Generic Data Grid for displaying data.
   * @param {Object} props
   * @param {string} props.title
   * @param {Array<Object>} props.data
   * @param {Array<Object>} props.columns - Array of { header, accessor, render? }
   * @param {function | null} props.onRowClick
   */
  const DataGrid = ({ title, data, columns, onRowClick }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });

    const filteredAndSortedData = useMemo(() => {
      let sortableItems = [...data];
      
      // 1. Filtering
      let filteredItems = sortableItems.filter(item => 
        Object.values(item).some(val => 
          String(val).toLowerCase().includes(searchTerm.toLowerCase())
        )
      );

      // 2. Sorting
      if (sortConfig.key !== null) {
        filteredItems.sort((a, b) => {
          const aVal = a[sortConfig.key] || '';
          const bVal = b[sortConfig.key] || '';
          if (aVal < bVal) {
            return sortConfig.direction === 'ascending' ? -1 : 1;
          }
          if (aVal > bVal) {
            return sortConfig.direction === 'ascending' ? 1 : -1;
          }
          return 0;
        });
      }
      return filteredItems;
    }, [data, searchTerm, sortConfig]);

    const requestSort = (key) => {
      let direction = 'ascending';
      if (sortConfig.key === key && sortConfig.direction === 'ascending') {
        direction = 'descending';
      }
      setSortConfig({ key, direction });
    };

    const getSortIcon = (key) => {
      if (sortConfig.key !== key) return <ArrowDownUp className='w-3 h-3 ml-1 text-gray-400'/>;
      if (sortConfig.direction === 'ascending') return <ArrowDownUp className='w-3 h-3 ml-1 rotate-180 text-indigo-600'/>;
      return <ArrowDownUp className='w-3 h-3 ml-1 text-indigo-600'/>;
    };

    return (
      <div className="bg-white p-6 rounded-xl shadow-lg">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-semibold text-gray-800">{title} ({filteredAndSortedData.length})</h3>
          <div className="relative">
            <input
              type="text"
              placeholder="Search..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 w-64"
            />
            <Filter className="w-5 h-5 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2" />
          </div>
        </div>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                {columns.map(col => (
                  <th
                    key={col.accessor}
                    onClick={() => requestSort(col.accessor)}
                    className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100 transition duration-150"
                  >
                    <div className="flex items-center">
                      {col.header}
                      {getSortIcon(col.accessor)}
                    </div>
                  </th>
                ))}
                {onRowClick && <th className="px-6 py-3"></th>} {/* Action Column */}
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredAndSortedData.map(item => (
                <tr 
                  key={item.id} 
                  className={`hover:bg-indigo-50 transition duration-150 ${onRowClick ? 'cursor-pointer' : ''}`}
                  onClick={() => onRowClick && onRowClick(item)}
                >
                  {columns.map(col => (
                    <td key={col.accessor} className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                      {col.render ? col.render(item[col.accessor], item) : item[col.accessor]}
                    </td>
                  ))}
                  {onRowClick && (
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <ArrowRight className='w-4 h-4 text-indigo-600 hover:text-indigo-900 inline-block'/>
                    </td>
                  )}
                </tr>
              ))}
              {filteredAndSortedData.length === 0 && (
                <tr>
                  <td colSpan={columns.length + (onRowClick ? 1 : 0)} className="px-6 py-4 text-center text-gray-500">
                    No matching records found.
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </div>
    );
  };

  /**
   * Generic CRUD (Create, Read, Update, Delete) View.
   * @param {Object} props
   * @param {string} props.title
   * @param {string} props.collectionName
   * @param {Array<Object>} props.data
   * @param {Object} props.initialForm
   * @param {Array<Object>} props.formFields - Array of { name, label, type, options? }
   * @param {function} props.saveDocument
   * @param {Array<Object>} props.tableColumns
   * @param {React.ReactNode} props.AssetIcon
   */
  const CrudView = ({ title, collectionName, data, initialForm, formFields, tableColumns, saveDocument, AssetIcon }) => {
    const [isFormOpen, setIsFormOpen] = useState(false);
    const [currentEdit, setCurrentEdit] = useState(null); // The document being edited
    const [formData, setFormData] = useState(initialForm);
    const [saveMessage, setSaveMessage] = useState(null);

    // Effect to reset form when closing or starting a new entry
    useEffect(() => {
        if (!isFormOpen) {
            setFormData(initialForm);
            setCurrentEdit(null);
            setSaveMessage(null);
        }
    }, [isFormOpen, initialForm]);

    const handleFormChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setSaveMessage('Saving...');
        await saveDocument(formData, currentEdit ? currentEdit.id : null);
        setSaveMessage(currentEdit ? 'Updated successfully!' : 'Created successfully!');
        
        // Auto-close form after a brief delay
        setTimeout(() => {
            setIsFormOpen(false);